<!DOCTYPE html>
<html lang="ko-KR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <script
    type="application/javascript"
    src='https://pink-spider.github.io/js/theme-mode.js'
  ></script>
  <link rel="stylesheet" href='https://pink-spider.github.io/css/frameworks.min.css' />
  <link rel="stylesheet" href='https://pink-spider.github.io/css/github.min.css' />
  <link rel="stylesheet" href='https://pink-spider.github.io/css/github-style.css' />
  <link rel="stylesheet" href='https://pink-spider.github.io/css/light.css' />
  <link rel="stylesheet" href='https://pink-spider.github.io/css/dark.css' />
  <link rel="stylesheet" href='https://pink-spider.github.io/css/syntax.css' />
  
  <link rel="stylesheet" href="/your%20css%20file%20name" />
  
  <title>
    QueryDSL을 사용할 때 데이터베이스의 Lock | Pink Spider
  </title>
  
  <link rel="icon" type="image/x-icon" href="/images/logo_pinkspider.png" />
  
  <meta name="theme-color" content="#1e2327" />

  
  <meta
  name="description"
  content="jwt 관련 Tip Q. access token 이 만료되면, refresh token을 통해 재발행 한다. refresh token은 만료 기간이 없을까? A. Refresh Token도 반드시 만료 기간이 있어야 합니다. 일반적으로는 Access Token보다 훨씬 긴 만료 기간을 설정할 뿐이에요. 1. 일반적인 만료 시간 설정 Access Token: 보통 15분 ~ 1시간 Refresh Token: 보통 7일 ~ 30일 또는 90일 2. 왜 Refresh Token도 만료 기간이 필요한가? Refresh Token이 유출되었을 경우, 무제한으로 Access Token을 재발급받을 수 있다면 보안에 치명적입니다. 일정 기간이 지나면 로그인 세션을 재확인하거나 재로그인을 유도하는 것이 보안상 더 안전합니다. 3. 저장 위치는? Refresh Token은 보통 서버 저장 방식 (e.g., Redis)에 저장하고, 사용자에게는 식별자만 전달하거나 클라이언트에 저장하되 보안적으로 안전한 저장소 (e.g., Secure Cookie, LocalStorage X) 를 사용하는 것이 권장됩니다. Q. Spring Boot에서의 예시 A. Spring Boot에서 JWT 기반으로 Access Token과 Refresh Token을 발급 및 재발급하는 기본적인 구조를 예시 1. 토큰 생성 클래스 (JwtProvider) @Component public class JwtProvider { private final String secretKey = &#34;yourSecretKey&#34;; // 적절히 암호화 필요 private final long accessTokenValidity = 1000L * 60 * 15; // 15분 private final long refreshTokenValidity = 1000L * 60 * 60 * 24 * 14; // 14일 public String createAccessToken(String userId) { return createToken(userId, accessTokenValidity); } public String createRefreshToken(String userId) { return createToken(userId, refreshTokenValidity); } private String createToken(String userId, long validity) { Claims claims = Jwts.claims().setSubject(userId); Date now = new Date(); Date expiry = new Date(now.getTime() &#43; validity); return Jwts.builder() .setClaims(claims) .setIssuedAt(now) .setExpiration(expiry) .signWith(SignatureAlgorithm.HS256, secretKey) .compact(); } public String getUserIdFromToken(String token) { return Jwts.parser().setSigningKey(secretKey) .parseClaimsJws(token).getBody().getSubject(); } public boolean validateToken(String token) { try { Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token); return true; } catch (ExpiredJwtException e) { return false; } } } 2. 로그인 시 토큰 발급 @PostMapping(&#34;/login&#34;) public ResponseEntity&lt;TokenResponse&gt; login(@RequestBody LoginRequest request) { // 인증 처리 (생략) String userId = &#34;user-id&#34;; String accessToken = jwtProvider.createAccessToken(userId); String refreshToken = jwtProvider.createRefreshToken(userId); // Refresh Token을 DB나 Redis에 저장 refreshTokenService.save(userId, refreshToken); return ResponseEntity.ok(new TokenResponse(accessToken, refreshToken)); } 3. Access Token 만료 시 Refresh Token으로 재발급 @PostMapping(&#34;/token/refresh&#34;) public ResponseEntity&lt;TokenResponse&gt; refreshToken(@RequestBody TokenRequest request) { String refreshToken = request.getRefreshToken(); if (!jwtProvider.validateToken(refreshToken)) { throw new RuntimeException(&#34;Invalid refresh token&#34;); } String userId = jwtProvider.getUserIdFromToken(refreshToken); // 저장된 refresh token과 비교 String stored = refreshTokenService.get(userId); if (!stored.equals(refreshToken)) { throw new RuntimeException(&#34;Token mismatch&#34;); } String newAccessToken = jwtProvider.createAccessToken(userId); return ResponseEntity.ok(new TokenResponse(newAccessToken, refreshToken)); } 4. Refresh Token 저장 예시 (Redis 기반) @Service public class RefreshTokenService { private final RedisTemplate&lt;String, String&gt; redisTemplate; public RefreshTokenService(RedisTemplate&lt;String, String&gt; redisTemplate) { this.redisTemplate = redisTemplate; } public void save(String userId, String token) { redisTemplate.opsForValue().set(userId, token, 14, TimeUnit.DAYS); // 유효 기간 설정 } public String get(String userId) { return redisTemplate.opsForValue().get(userId); } } Q. 에시에서 RefreshToken 에서 refresh save전에 기존꺼는 안지워도 될까? A. 일반적으로는 기존 Refresh Token을 삭제하거나 덮어써야 합니다. 왜냐면:
"
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://pink-spider.github.io/post/til/jwt/jwt_strategy/" />


<meta name="twitter:card" content="summary" />
<meta
  name="twitter:title"
  content="QueryDSL을 사용할 때 데이터베이스의 Lock - Pink Spider"
/>
<meta
  name="twitter:description"
  content="jwt 관련 Tip Q. access token 이 만료되면, refresh token을 통해 재발행 한다. refresh token은 만료 기간이 없을까? A. Refresh Token도 반드시 만료 기간이 있어야 합니다. 일반적으로는 Access Token보다 훨씬 긴 만료 기간을 설정할 뿐이에요. 1. 일반적인 만료 시간 설정 Access Token: 보통 15분 ~ 1시간 Refresh Token: 보통 7일 ~ 30일 또는 90일 2. 왜 Refresh Token도 만료 기간이 필요한가? Refresh Token이 유출되었을 경우, 무제한으로 Access Token을 재발급받을 수 있다면 보안에 치명적입니다. 일정 기간이 지나면 로그인 세션을 재확인하거나 재로그인을 유도하는 것이 보안상 더 안전합니다. 3. 저장 위치는? Refresh Token은 보통 서버 저장 방식 (e.g., Redis)에 저장하고, 사용자에게는 식별자만 전달하거나 클라이언트에 저장하되 보안적으로 안전한 저장소 (e.g., Secure Cookie, LocalStorage X) 를 사용하는 것이 권장됩니다. Q. Spring Boot에서의 예시 A. Spring Boot에서 JWT 기반으로 Access Token과 Refresh Token을 발급 및 재발급하는 기본적인 구조를 예시 1. 토큰 생성 클래스 (JwtProvider) @Component public class JwtProvider { private final String secretKey = &#34;yourSecretKey&#34;; // 적절히 암호화 필요 private final long accessTokenValidity = 1000L * 60 * 15; // 15분 private final long refreshTokenValidity = 1000L * 60 * 60 * 24 * 14; // 14일 public String createAccessToken(String userId) { return createToken(userId, accessTokenValidity); } public String createRefreshToken(String userId) { return createToken(userId, refreshTokenValidity); } private String createToken(String userId, long validity) { Claims claims = Jwts.claims().setSubject(userId); Date now = new Date(); Date expiry = new Date(now.getTime() &#43; validity); return Jwts.builder() .setClaims(claims) .setIssuedAt(now) .setExpiration(expiry) .signWith(SignatureAlgorithm.HS256, secretKey) .compact(); } public String getUserIdFromToken(String token) { return Jwts.parser().setSigningKey(secretKey) .parseClaimsJws(token).getBody().getSubject(); } public boolean validateToken(String token) { try { Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token); return true; } catch (ExpiredJwtException e) { return false; } } } 2. 로그인 시 토큰 발급 @PostMapping(&#34;/login&#34;) public ResponseEntity&lt;TokenResponse&gt; login(@RequestBody LoginRequest request) { // 인증 처리 (생략) String userId = &#34;user-id&#34;; String accessToken = jwtProvider.createAccessToken(userId); String refreshToken = jwtProvider.createRefreshToken(userId); // Refresh Token을 DB나 Redis에 저장 refreshTokenService.save(userId, refreshToken); return ResponseEntity.ok(new TokenResponse(accessToken, refreshToken)); } 3. Access Token 만료 시 Refresh Token으로 재발급 @PostMapping(&#34;/token/refresh&#34;) public ResponseEntity&lt;TokenResponse&gt; refreshToken(@RequestBody TokenRequest request) { String refreshToken = request.getRefreshToken(); if (!jwtProvider.validateToken(refreshToken)) { throw new RuntimeException(&#34;Invalid refresh token&#34;); } String userId = jwtProvider.getUserIdFromToken(refreshToken); // 저장된 refresh token과 비교 String stored = refreshTokenService.get(userId); if (!stored.equals(refreshToken)) { throw new RuntimeException(&#34;Token mismatch&#34;); } String newAccessToken = jwtProvider.createAccessToken(userId); return ResponseEntity.ok(new TokenResponse(newAccessToken, refreshToken)); } 4. Refresh Token 저장 예시 (Redis 기반) @Service public class RefreshTokenService { private final RedisTemplate&lt;String, String&gt; redisTemplate; public RefreshTokenService(RedisTemplate&lt;String, String&gt; redisTemplate) { this.redisTemplate = redisTemplate; } public void save(String userId, String token) { redisTemplate.opsForValue().set(userId, token, 14, TimeUnit.DAYS); // 유효 기간 설정 } public String get(String userId) { return redisTemplate.opsForValue().get(userId); } } Q. 에시에서 RefreshToken 에서 refresh save전에 기존꺼는 안지워도 될까? A. 일반적으로는 기존 Refresh Token을 삭제하거나 덮어써야 합니다. 왜냐면:
"
/>
<meta name="twitter:site" content="https://pink-spider.github.io/" />
<meta name="twitter:creator" content="" />
<meta
  name="twitter:image"
  content="https://pink-spider.github.io/"
/>


<meta
  property="og:type"
  content="article"
/>
<meta
  property="og:title"
  content="QueryDSL을 사용할 때 데이터베이스의 Lock - Pink Spider"
/>
<meta
  property="og:description"
  content="jwt 관련 Tip Q. access token 이 만료되면, refresh token을 통해 재발행 한다. refresh token은 만료 기간이 없을까? A. Refresh Token도 반드시 만료 기간이 있어야 합니다. 일반적으로는 Access Token보다 훨씬 긴 만료 기간을 설정할 뿐이에요. 1. 일반적인 만료 시간 설정 Access Token: 보통 15분 ~ 1시간 Refresh Token: 보통 7일 ~ 30일 또는 90일 2. 왜 Refresh Token도 만료 기간이 필요한가? Refresh Token이 유출되었을 경우, 무제한으로 Access Token을 재발급받을 수 있다면 보안에 치명적입니다. 일정 기간이 지나면 로그인 세션을 재확인하거나 재로그인을 유도하는 것이 보안상 더 안전합니다. 3. 저장 위치는? Refresh Token은 보통 서버 저장 방식 (e.g., Redis)에 저장하고, 사용자에게는 식별자만 전달하거나 클라이언트에 저장하되 보안적으로 안전한 저장소 (e.g., Secure Cookie, LocalStorage X) 를 사용하는 것이 권장됩니다. Q. Spring Boot에서의 예시 A. Spring Boot에서 JWT 기반으로 Access Token과 Refresh Token을 발급 및 재발급하는 기본적인 구조를 예시 1. 토큰 생성 클래스 (JwtProvider) @Component public class JwtProvider { private final String secretKey = &#34;yourSecretKey&#34;; // 적절히 암호화 필요 private final long accessTokenValidity = 1000L * 60 * 15; // 15분 private final long refreshTokenValidity = 1000L * 60 * 60 * 24 * 14; // 14일 public String createAccessToken(String userId) { return createToken(userId, accessTokenValidity); } public String createRefreshToken(String userId) { return createToken(userId, refreshTokenValidity); } private String createToken(String userId, long validity) { Claims claims = Jwts.claims().setSubject(userId); Date now = new Date(); Date expiry = new Date(now.getTime() &#43; validity); return Jwts.builder() .setClaims(claims) .setIssuedAt(now) .setExpiration(expiry) .signWith(SignatureAlgorithm.HS256, secretKey) .compact(); } public String getUserIdFromToken(String token) { return Jwts.parser().setSigningKey(secretKey) .parseClaimsJws(token).getBody().getSubject(); } public boolean validateToken(String token) { try { Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token); return true; } catch (ExpiredJwtException e) { return false; } } } 2. 로그인 시 토큰 발급 @PostMapping(&#34;/login&#34;) public ResponseEntity&lt;TokenResponse&gt; login(@RequestBody LoginRequest request) { // 인증 처리 (생략) String userId = &#34;user-id&#34;; String accessToken = jwtProvider.createAccessToken(userId); String refreshToken = jwtProvider.createRefreshToken(userId); // Refresh Token을 DB나 Redis에 저장 refreshTokenService.save(userId, refreshToken); return ResponseEntity.ok(new TokenResponse(accessToken, refreshToken)); } 3. Access Token 만료 시 Refresh Token으로 재발급 @PostMapping(&#34;/token/refresh&#34;) public ResponseEntity&lt;TokenResponse&gt; refreshToken(@RequestBody TokenRequest request) { String refreshToken = request.getRefreshToken(); if (!jwtProvider.validateToken(refreshToken)) { throw new RuntimeException(&#34;Invalid refresh token&#34;); } String userId = jwtProvider.getUserIdFromToken(refreshToken); // 저장된 refresh token과 비교 String stored = refreshTokenService.get(userId); if (!stored.equals(refreshToken)) { throw new RuntimeException(&#34;Token mismatch&#34;); } String newAccessToken = jwtProvider.createAccessToken(userId); return ResponseEntity.ok(new TokenResponse(newAccessToken, refreshToken)); } 4. Refresh Token 저장 예시 (Redis 기반) @Service public class RefreshTokenService { private final RedisTemplate&lt;String, String&gt; redisTemplate; public RefreshTokenService(RedisTemplate&lt;String, String&gt; redisTemplate) { this.redisTemplate = redisTemplate; } public void save(String userId, String token) { redisTemplate.opsForValue().set(userId, token, 14, TimeUnit.DAYS); // 유효 기간 설정 } public String get(String userId) { return redisTemplate.opsForValue().get(userId); } } Q. 에시에서 RefreshToken 에서 refresh save전에 기존꺼는 안지워도 될까? A. 일반적으로는 기존 Refresh Token을 삭제하거나 덮어써야 합니다. 왜냐면:
"
/>
<meta property="og:url" content="https://pink-spider.github.io/post/til/jwt/jwt_strategy/" />
<meta property="og:site_name" content="QueryDSL을 사용할 때 데이터베이스의 Lock" />
<meta
  property="og:image"
  content="https://pink-spider.github.io/"
/>
<meta property="og:image:width" content="2048" />
<meta property="og:image:height" content="1024" />

<meta property="article:published_time" content="2025-03-27 11:36:45 &#43;0900 KST" />















</head>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6329038356545416"
        crossorigin="anonymous"></script>

<body>
  

<style>
  .height-limitation {
    max-height: 300px;
    overflow-y: scroll;
  }

  .loader {
    border: 4px solid #f3f3f3;
    border-bottom: 4px solid var(--color-fg-muted);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
</style>

<div style="position: relative">
  <header
    class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on"
  >
    <div
      class="Header-item mobile-none"
      style="margin-top: -4px; margin-bottom: -4px"
    >
      <a class="Header-link" href="https://pink-spider.github.io/" aria-label="Home">
        <svg
          class="octicon"
          height="32"
          viewBox="0 0 16 16"
          version="1.1"
          width="32"
        >
          <path
            fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
          ></path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button
        class="Header-link btn-link js-details-target"
        type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'"
        aria-label="Search"
      >
        <svg
          height="24"
          class="octicon octicon-three-bars"
          viewBox="0 0 16 16"
          version="1.1"
          width="24"
        >
          <path
            fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z"
          ></path>
        </svg>
      </button>
    </div>
    <div
      style="display: none"
      id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex"
    >
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to"
      >
        <div class="position-relative">
          <form
            target="_blank"
            action="https://www.google.com/search"
            accept-charset="UTF-8"
            method="get"
            autocomplete="off"
          >
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center"
            >
              <input
                type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q"
                value=""
                placeholder="Search"
                autocomplete="off"
              />
              <input type="hidden" name="q" value="site:https://pink-spider.github.io/" />
              <div
                class="js-jump-to-suggestions-container jump-to-suggestions overflow-hidden position-absolute"
              >
                <div
                  id="search-progress"
                  class="d-none color-bg-primary no-underline p-2"
                  role="progress"
                  aria-selected="false"
                >
                  <div class="loader"></div>
                </div>

                <ul
                  id="jump-to-results"
                  role="listbox"
                  class="Box border-0 p-0 m-0 js-navigation-container jump-to-suggestions-results-container js-jump-to-suggestions-results-container js-active-navigation-container height-limitation"
                ></ul>
              </div>
            </label>
          </form>
        </div>
      </div>
    </div>

    <div
      class="Header-item Header-item--full flex-justify-center d-md-none position-relative"
    >
      <a class="Header-link" href="https://pink-spider.github.io/" aria-label="Home">
        <svg
          class="octicon octicon-mark-github v-align-middle"
          height="32"
          viewBox="0 0 16 16"
          version="1.1"
          width="32"
        >
          <path
            fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
          ></path>
        </svg>
      </a>
    </div>
    <div class="Theme-switcher Header-item" style="margin-right: 0">
      <span
        role="button"
        class="Header-link no-select"
        onclick="switchTheme()"
        style="cursor: pointer"
        aria-label="Switch theme"
      >
        <svg
          style="fill: var(--color-profile-color-modes-toggle-moon)"
          class="no-select"
          viewBox="0 0 16 16"
          version="1.1"
          width="16"
          height="16"
        >
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z"
          ></path>
        </svg>
      </span>
    </div>
  </header>
</div>

  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://pink-spider.github.io/">
                  <img class=" avatar-user"
                    src="/images/logo_pinkspider.png"
                    width="32" height="32" alt="Pink Spider"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://pink-spider.github.io/">Pink Spider</a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://pink-spider.github.io/post/til/jwt/jwt_strategy/">QueryDSL을 사용할 때 데이터베이스의 Lock</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Thu, 27 Mar 2025 11:36:45 &#43;0900"
                    class="no-wrap">
                    Thu, 27 Mar 2025 11:36:45 &#43;0900</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Thu, 01 May 2025 23:38:46 &#43;0900"
                    class="no-wrap">
                    Thu, 01 May 2025 23:38:46 &#43;0900</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      2341 Words
                    <span class="file-info-divider"></span>
                                        11 min

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="jwt-관련-tip">jwt 관련 Tip</h1>
<h2 id="q-access-token-이-만료되면-refresh-token을-통해-재발행-한다-refresh-token은-만료-기간이-없을까">Q. access token 이 만료되면, refresh token을 통해 재발행 한다. refresh token은 만료 기간이 없을까?</h2>
<h2 id="a-refresh-token도-반드시-만료-기간이-있어야-합니다">A. <code>Refresh Token</code>도 <strong>반드시 만료 기간이 있어야</strong> 합니다.</h2>
<ul>
<li>일반적으로는 <code>Access Token</code>보다 <strong>훨씬 긴 만료 기간</strong>을 설정할 뿐이에요.</li>
</ul>
<h3 id="1-일반적인-만료-시간-설정">1. 일반적인 만료 시간 설정</h3>
<ul>
<li><strong>Access Token</strong>: 보통 <strong>15분 ~ 1시간</strong></li>
<li><strong>Refresh Token</strong>: 보통 <strong>7일 ~ 30일</strong> 또는 <strong>90일</strong></li>
</ul>
<hr>
<h3 id="2-왜-refresh-token도-만료-기간이-필요한가">2. 왜 Refresh Token도 만료 기간이 필요한가?</h3>
<ul>
<li>Refresh Token이 <strong>유출되었을 경우</strong>, 무제한으로 Access Token을 재발급받을 수 있다면 <strong>보안에 치명적</strong>입니다.</li>
<li>일정 기간이 지나면 <strong>로그인 세션을 재확인</strong>하거나 <strong>재로그인</strong>을 유도하는 것이 보안상 더 안전합니다.</li>
</ul>
<hr>
<h3 id="3-저장-위치는">3. 저장 위치는?</h3>
<ul>
<li>Refresh Token은 보통 <strong>서버 저장 방식</strong> (e.g., Redis)에 저장하고, 사용자에게는 식별자만 전달하거나 클라이언트에 저장하되 <strong>보안적으로 안전한 저장소</strong> (e.g., Secure Cookie, LocalStorage X) 를 사용하는 것이 권장됩니다.</li>
</ul>
<hr>
<h2 id="q-spring-boot에서의-예시">Q. Spring Boot에서의 예시</h2>
<h2 id="a-spring-boot에서-jwt-기반으로-access-token과-refresh-token을-발급-및-재발급하는-기본적인-구조를-예시">A. Spring Boot에서 JWT 기반으로 Access Token과 Refresh Token을 발급 및 재발급하는 기본적인 구조를 예시</h2>
<hr>
<h3 id="1-토큰-생성-클래스-jwtprovider"><strong>1. 토큰 생성 클래스 (JwtProvider)</strong></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">JwtProvider</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">secretKey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;yourSecretKey&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 적절히 암호화 필요</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">accessTokenValidity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1000L</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">15</span><span class="p">;</span><span class="w">  </span><span class="c1">// 15분</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">refreshTokenValidity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1000L</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">24</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">14</span><span class="p">;</span><span class="w"> </span><span class="c1">// 14일</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">createAccessToken</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">userId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">createToken</span><span class="p">(</span><span class="n">userId</span><span class="p">,</span><span class="w"> </span><span class="n">accessTokenValidity</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">createRefreshToken</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">userId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">createToken</span><span class="p">(</span><span class="n">userId</span><span class="p">,</span><span class="w"> </span><span class="n">refreshTokenValidity</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">createToken</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">userId</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">validity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Claims</span><span class="w"> </span><span class="n">claims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Jwts</span><span class="p">.</span><span class="na">claims</span><span class="p">().</span><span class="na">setSubject</span><span class="p">(</span><span class="n">userId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Date</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Date</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Date</span><span class="w"> </span><span class="n">expiry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Date</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="na">getTime</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">validity</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Jwts</span><span class="p">.</span><span class="na">builder</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">setClaims</span><span class="p">(</span><span class="n">claims</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">setIssuedAt</span><span class="p">(</span><span class="n">now</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">setExpiration</span><span class="p">(</span><span class="n">expiry</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">signWith</span><span class="p">(</span><span class="n">SignatureAlgorithm</span><span class="p">.</span><span class="na">HS256</span><span class="p">,</span><span class="w"> </span><span class="n">secretKey</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">compact</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">getUserIdFromToken</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">token</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Jwts</span><span class="p">.</span><span class="na">parser</span><span class="p">().</span><span class="na">setSigningKey</span><span class="p">(</span><span class="n">secretKey</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">parseClaimsJws</span><span class="p">(</span><span class="n">token</span><span class="p">).</span><span class="na">getBody</span><span class="p">().</span><span class="na">getSubject</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">validateToken</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">token</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Jwts</span><span class="p">.</span><span class="na">parser</span><span class="p">().</span><span class="na">setSigningKey</span><span class="p">(</span><span class="n">secretKey</span><span class="p">).</span><span class="na">parseClaimsJws</span><span class="p">(</span><span class="n">token</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">ExpiredJwtException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h3 id="2-로그인-시-토큰-발급"><strong>2. 로그인 시 토큰 발급</strong></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@PostMapping</span><span class="p">(</span><span class="s">&#34;/login&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">ResponseEntity</span><span class="o">&lt;</span><span class="n">TokenResponse</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">login</span><span class="p">(</span><span class="nd">@RequestBody</span><span class="w"> </span><span class="n">LoginRequest</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 인증 처리 (생략)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">userId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;user-id&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">accessToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jwtProvider</span><span class="p">.</span><span class="na">createAccessToken</span><span class="p">(</span><span class="n">userId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">refreshToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jwtProvider</span><span class="p">.</span><span class="na">createRefreshToken</span><span class="p">(</span><span class="n">userId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Refresh Token을 DB나 Redis에 저장</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">refreshTokenService</span><span class="p">.</span><span class="na">save</span><span class="p">(</span><span class="n">userId</span><span class="p">,</span><span class="w"> </span><span class="n">refreshToken</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ResponseEntity</span><span class="p">.</span><span class="na">ok</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">TokenResponse</span><span class="p">(</span><span class="n">accessToken</span><span class="p">,</span><span class="w"> </span><span class="n">refreshToken</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h3 id="3-access-token-만료-시-refresh-token으로-재발급"><strong>3. Access Token 만료 시 Refresh Token으로 재발급</strong></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@PostMapping</span><span class="p">(</span><span class="s">&#34;/token/refresh&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">ResponseEntity</span><span class="o">&lt;</span><span class="n">TokenResponse</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">refreshToken</span><span class="p">(</span><span class="nd">@RequestBody</span><span class="w"> </span><span class="n">TokenRequest</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">refreshToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="na">getRefreshToken</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">jwtProvider</span><span class="p">.</span><span class="na">validateToken</span><span class="p">(</span><span class="n">refreshToken</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&#34;Invalid refresh token&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">userId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jwtProvider</span><span class="p">.</span><span class="na">getUserIdFromToken</span><span class="p">(</span><span class="n">refreshToken</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 저장된 refresh token과 비교</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">stored</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">refreshTokenService</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">userId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">stored</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">refreshToken</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&#34;Token mismatch&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">newAccessToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jwtProvider</span><span class="p">.</span><span class="na">createAccessToken</span><span class="p">(</span><span class="n">userId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ResponseEntity</span><span class="p">.</span><span class="na">ok</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">TokenResponse</span><span class="p">(</span><span class="n">newAccessToken</span><span class="p">,</span><span class="w"> </span><span class="n">refreshToken</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h3 id="4-refresh-token-저장-예시-redis-기반"><strong>4. Refresh Token 저장 예시 (Redis 기반)</strong></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">RefreshTokenService</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">RedisTemplate</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">redisTemplate</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">RefreshTokenService</span><span class="p">(</span><span class="n">RedisTemplate</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">redisTemplate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">redisTemplate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">redisTemplate</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">userId</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">token</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">set</span><span class="p">(</span><span class="n">userId</span><span class="p">,</span><span class="w"> </span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">14</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">DAYS</span><span class="p">);</span><span class="w"> </span><span class="c1">// 유효 기간 설정</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">userId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="n">userId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="q-에시에서-refreshtoken-에서-refresh-save전에-기존꺼는-안지워도-될까">Q. 에시에서 RefreshToken 에서 refresh save전에 기존꺼는 안지워도 될까?</h2>
<h2 id="a-일반적으로는-기존-refresh-token을-삭제하거나-덮어써야-합니다">A. 일반적으로는 <strong>기존 Refresh Token을 삭제하거나 덮어써야 합니다</strong>.</h2>
<p>왜냐면:</p>
<ul>
<li><strong>하나의 유저당 하나의 Refresh Token만 유효</strong>하도록 관리하는 게 일반적인 보안 패턴이에요.</li>
<li>그렇지 않으면 이전에 발급된 토큰으로도 계속 Access Token을 재발급받을 수 있어, <strong>탈취된 토큰을 막기 어려워짐</strong>.</li>
</ul>
<hr>
<h3 id="-덮어쓰는-방식이면-ok">✅ 덮어쓰는 방식이면 OK</h3>
<p>Redis에서 <code>SET</code> 명령은 기본적으로 <strong>같은 key면 덮어씁니다.</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">set</span><span class="p">(</span><span class="n">userId</span><span class="p">,</span><span class="w"> </span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">14</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">DAYS</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>위 코드는 기존 토큰을 <strong>자동으로 덮어쓰기 때문에 별도 삭제는 필요 없습니다.</strong></p>
<hr>
<h3 id="-만약-여러-refresh-token을-허용하고-싶다면">✅ 만약 여러 Refresh Token을 허용하고 싶다면?</h3>
<p>예: 여러 디바이스 로그인 허용 시</p>
<ul>
<li><code>userId:deviceId</code> 형태로 Redis 키를 저장하거나</li>
<li>Refresh Token 자체를 key로 저장하고, userId를 값으로 두는 구조 등으로 <strong>토큰 여러 개</strong>를 관리할 수 있어요.</li>
</ul>
<hr>
<p>요약:</p>
<ul>
<li><strong>유저당 1개의 토큰 정책이라면</strong>, 현재 방식처럼 <code>set()</code>만으로도 충분합니다.</li>
<li>보안 강화가 목적이라면 <strong>토큰 변경 시마다 재발급 및 교체하는 방식</strong>이 맞습니다.</li>
</ul>
<h2 id="q-refresh-token이-만료되면-갱신은-어떻게-하나요">Q. refresh token이 만료되면 갱신은 어떻게 하나요?</h2>
<h2 id="a-refresh-token이-만료된-경우에는-자동-갱신할-수-없고-사용자는">A. <strong>Refresh Token이 만료된 경우에는 자동 갱신할 수 없고, 사용자는 <em>재로그인</em> 해야 합니다.</strong></h2>
<p>즉, 유저 인증을 다시 받아야 새로운 Access/Refresh Token을 발급할 수 있어요.</p>
<hr>
<h3 id="-갱신-흐름-정리">🔁 갱신 흐름 정리</h3>
<table>
  <thead>
      <tr>
          <th>상황</th>
          <th>처리 방식</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>✅ Access Token 만료</td>
          <td>Refresh Token으로 Access Token 재발급</td>
      </tr>
      <tr>
          <td>❌ Refresh Token 만료</td>
          <td>사용자가 <strong>재로그인</strong>해야 함</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="왜-자동-갱신이-안-될까">왜 자동 갱신이 안 될까?</h3>
<p>Refresh Token은 이미 **&ldquo;로그인 상태를 유지하는 유일한 증거&rdquo;**예요.<br>
이게 만료됐다는 건 서버 입장에선 &ldquo;이 사용자가 여전히 로그인 상태라고 신뢰할 수 없다&quot;는 뜻이죠.<br>
→ 그래서 반드시 사용자의 **다시 인증 (ex. 아이디/비밀번호 로그인, OAuth 등)**이 필요해요.</p>
<hr>
<h3 id="-실무에서의-ux-처리">💡 실무에서의 UX 처리</h3>
<ul>
<li>클라이언트가 토큰 만료 에러 받으면:
<ul>
<li><strong>Access Token 만료</strong> → 자동 재발급 시도</li>
<li><strong>Refresh Token 만료</strong> → 사용자에게 &ldquo;세션이 만료되었습니다. 다시 로그인 해주세요&rdquo; 메시지</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">401</span> <span class="ne">Unauthorized</span>
</span></span><span class="line"><span class="cl"><span class="err">{</span>
</span></span><span class="line"><span class="cl"><span class="g">  &#34;code&#34;: &#34;REFRESH_TOKEN_EXPIRED&#34;,
</span></span></span><span class="line"><span class="cl"><span class="g">  &#34;message&#34;: &#34;세션이 만료되었습니다. 다시 로그인 해주세요.&#34;
</span></span></span><span class="line"><span class="cl"><span class="g">}
</span></span></span></code></pre></div><hr>
<h3 id="추가-팁">추가 팁</h3>
<ul>
<li>프론트에서 <code>accessToken</code>과 <code>refreshToken</code>의 만료 시간을 관리해두면 사용자 경험 개선 가능</li>
<li>백엔드에서 <code>Refresh Token</code> 만료 시 <strong>로그아웃 처리</strong>를 해두는 것도 깔끔한 방식이에요 (e.g., Redis에서 토큰 삭제)</li>
</ul>
<hr>
<h2 id="q-재로그인-안하고-로그인을-유지할-방법은-없을까요">Q. 재로그인 안하고, 로그인을 유지할 방법은 없을까요?</h2>
<h2 id="a-refresh-token까지-만료됐는데-재로그인-없이-로그인-상태-유지를-원한다면-일반적인-보안-정책에서는-권장되지-않지만-일부-대안적인-방법이-있습니다-각각의-보안-트레이드오프를-이해하고-선택하는-게-중요해요">A. &ldquo;<strong>Refresh Token까지 만료됐는데 재로그인 없이 로그인 상태 유지</strong>&ldquo;를 원한다면, <strong>일반적인 보안 정책에서는 권장되지 않지만</strong>, 일부 대안적인 방법이 있습니다. 각각의 <strong>보안 트레이드오프</strong>를 이해하고 선택하는 게 중요해요.</h2>
<hr>
<h3 id="-1-refresh-token-rotation--sliding-expiration-슬라이딩-만료">✅ 1. <strong>Refresh Token Rotation + Sliding Expiration (슬라이딩 만료)</strong></h3>
<blockquote>
<p>만료 시간을 매번 연장하는 방식</p></blockquote>
<h4 id="-어떻게-작동하나요">🔄 어떻게 작동하나요?</h4>
<ul>
<li>사용자가 <strong>Refresh Token으로 Access Token을 재발급할 때마다</strong>,<br>
<strong>새로운 Refresh Token도 함께 재발급</strong>해서 <strong>유효 기간을 갱신</strong>해줍니다.</li>
<li>이걸 계속 반복하면, 사용자는 <strong>로그인 유지</strong>가 가능하죠.</li>
</ul>
<h4 id="-장점">✅ 장점</h4>
<ul>
<li>사용자가 <strong>장시간 활동하면 로그인 유지 가능</strong></li>
<li>UX가 훨씬 부드러움 (카카오/구글 등도 유사 전략 사용)</li>
</ul>
<h4 id="-단점">❌ 단점</h4>
<ul>
<li><strong>Refresh Token 탈취 시 위험</strong> (회전 로직을 모르면 계속 사용 가능)</li>
<li><strong>서버 상태 저장 필요</strong> (Redis 등으로 마지막 토큰 상태 관리해야 함)</li>
</ul>
<hr>
<h3 id="-2-long-lived-refresh-token">✅ 2. <strong>Long-lived Refresh Token</strong></h3>
<blockquote>
<p>Refresh Token을 <strong>매우 길게</strong> 설정 (예: 180일)</p></blockquote>
<ul>
<li>토큰 자체는 그대로지만, 서버에서 <strong>마지막 사용 시간</strong>을 기준으로 만료 처리</li>
<li>또는 그냥 클라이언트에 오래 살아있는 refresh token을 두는 전략</li>
</ul>
<h4 id="-장점-1">✅ 장점</h4>
<ul>
<li>사용자 재로그인 필요 없음</li>
</ul>
<h4 id="-단점-1">❌ 단점</h4>
<ul>
<li>유출되면 <strong>오랫동안 사용 가능</strong></li>
<li>모바일 앱에만 제한적으로 사용 (보안 컨트롤 쉬움)</li>
</ul>
<hr>
<h3 id="-3-silent-re-authentication-조용한-재인증">✅ 3. <strong>Silent Re-authentication (조용한 재인증)</strong></h3>
<blockquote>
<p>OAuth2 기반에서는 <strong>Refresh Token이 만료되더라도</strong>,<br>
<strong>사용자가 여전히 세션에 로그인되어 있다면</strong>,<br>
<strong>백그라운드에서 재로그인 요청</strong>이 가능함</p></blockquote>
<ul>
<li>예: Google OAuth → <code>prompt=none</code> 파라미터로 로그인 페이지 없이 다시 인증 가능</li>
<li>조건: 사용자가 아직 Google에 로그인 상태여야 함</li>
</ul>
<hr>
<h3 id="-현실적인-전략">💡 현실적인 전략</h3>
<table>
  <thead>
      <tr>
          <th>사용자 환경</th>
          <th>추천 전략</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>모바일 앱</td>
          <td>긴 Refresh Token + Secure Storage + Rotation</td>
      </tr>
      <tr>
          <td>웹 (보안 중요)</td>
          <td>Rotation + Redis 관리 + 주기적 재로그인 유도</td>
      </tr>
      <tr>
          <td>OAuth 로그인 (Google 등)</td>
          <td>Silent Re-authentication</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="마무리-요약">마무리 요약</h3>
<blockquote>
<p>Refresh Token 없이 로그인 유지하는 건 <strong>보안 리스크</strong>가 크지만,<br>
&ldquo;갱신 전략&quot;이나 &ldquo;OAuth 세션 기반 재인증&rdquo; 등을 잘 활용하면,<br>
UX와 보안 사이 균형을 잡을 수 있어요.</p></blockquote>
<hr>
</article>
              </div>

              
            </div>
          </div>
        </div>
      </div>

      <div class="pagination-nav">
        <div class="pagination-button next-post">
          
          <div>«&nbsp;</div><a class="pagination-link link-reverse" href="https://pink-spider.github.io/post/spring/basic/gateway_cors/"> Spring Gateway Cors 설장하기</a>
          
        </div>
        
        <div class="pagination-button previous-post">
          
          <a class="pagination-link link-reverse" href="https://pink-spider.github.io/post/infra/kafka/kakfa_fallback/">Apache Kafka 사용 시 코드로 오류 처리 방법&nbsp;</a><div> »</div>
          
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://pink-spider.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://pink-spider.github.io/css/toc.css' />

<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://pink-spider.github.io/css/gitalk.css'>
<script src='https://pink-spider.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    accessToken: '',
    repo: 'pink-spider.github.io',
    owner: 'pink-spider',
    admin: ['pink-spider'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>


  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light"
  >
    <ul
      class="list-style-none d-flex flex-wrap col-12 flex-justify-center mb-2 mb-lg-0"
    >
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>
</div>

</body>

<script type="application/javascript" src="https://pink-spider.github.io/js/github-style.js"></script>

<script src="https://pink-spider.github.io/js/mark.es6.min.js"></script>


<script type="text/javascript">

  const host = window.location.host;
  const keyword = localStorage.getItem('keyword');
  localStorage.removeItem('keyword');

  if (keyword) {
    const markInstance = new Mark(document.body);
    markInstance.unmark({
      done: function() {
        markInstance.mark(keyword);
      }
    });
  }

  const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--color-bg-primary');
  const mutedColor = getComputedStyle(document.documentElement).getPropertyValue('--color-fg-muted');
  const hoverColor = '#216EEB';

  let originalStyle;
  let svgOriginalStyle;
  let titleOriginalStyle;

  const onMouseOver = (node) => {
    originalStyle = Object.assign({}, node.style);
    node.style.backgroundColor = hoverColor;

    const child = node.querySelector('.js-jump');
    child.classList.remove('d-on-nav-focus');

    const title = node.querySelector('.title');
    if (title && primaryColor === ' #fff') {
      titleOriginalStyle = title.style;
      title.style.color = '#fff';
    }

    const svg = node.querySelector('.octicon');
    if (svg) {
      svgOriginalStyle = svg.style;
      svg.style.color = '#fff';
    }
  }

  const onMouseLeave = (node) => {
    node.style = originalStyle;
    const child = node.querySelector('.js-jump');
    child.classList.add('d-on-nav-focus');

    const title = node.querySelector('.title');
    title.style = titleOriginalStyle;

    const svg = node.querySelector('.octicon');
    svg.style = svgOriginalStyle;
  }

  const createSearchItem = (title, link, index) => {
    return `
    <li class="color-bg-primary search-item d-flex flex-justify-start flex-items-center p-0 f5 navigation-item js-navigation-item js-jump-to-scoped-search"
        role="option" aria-selected="false" tabindex="${index}">
        <a onmouseover="onMouseOver(this)" onmouseleave="onMouseLeave(this)"
          class="no-underline d-flex flex-auto flex-items-center jump-to-suggestions-path js-jump-to-suggestion-path js-navigation-open p-2"
          href="${link}" data-item-type="scoped_search">
          <div class="jump-to-octicon js-jump-to-octicon flex-shrink-0 mr-2 text-center ">
            <svg title="Repository" aria-label="Repository" role="img" height="16" viewBox="0 0 16 16"
              version="1.1" width="16" data-view-component="true"
              class="octicon octicon-repo js-jump-to-octicon-repo  flex-shrink-0">
              <path fill-rule="evenodd"
                d="M2 2.5A2.5 2.5 0 014.5 0h8.75a.75.75 0 01.75.75v12.5a.75.75 0 01-.75.75h-2.5a.75.75 0 110-1.5h1.75v-2h-8a1 1 0 00-.714 1.7.75.75 0 01-1.072 1.05A2.495 2.495 0 012 11.5v-9zm10.5-1V9h-8c-.356 0-.694.074-1 .208V2.5a1 1 0 011-1h8zM5 12.25v3.25a.25.25 0 00.4.2l1.45-1.087a.25.25 0 01.3 0L8.6 15.7a.25.25 0 00.4-.2v-3.25a.25.25 0 00-.25-.25h-3.5a.25.25 0 00-.25.25z">
              </path>
            </svg>
          </div>    

          <div
            class="title jump-to-suggestion-name js-jump-to-suggestion-name flex-auto overflow-hidden text-left no-wrap css-truncate css-truncate-target">
            ${title}
          </div>

          <div aria-hidden="true" style="color: var(--color-fg-muted);"
            class="color-bg-primary js-jump border rounded-2 flex-shrink-0 color-bg-subtle px-1 ml-1 f6 d-on-nav-focus js-jump-to-badge-jump">
            Jump to
            <span class="d-inline-block ml-1 v-align-middle">↵</span>
          </div>
        </a>
      </li>
    `
  }

  const createGoogleSearchItem = (keyword) => {
    return `
    <li class="color-bg-primary search-item d-flex flex-justify-start flex-items-center p-0 f5 navigation-item js-navigation-item js-jump-to-scoped-search"
        role="option" aria-selected="false" tabindex="0">
        <a onmouseover="onMouseOver(this)" onmouseleave="onMouseLeave(this)"
          class="no-underline d-flex flex-auto flex-items-center jump-to-suggestions-path js-jump-to-suggestion-path js-navigation-open p-2"
          href="https://www.google.com/search?q=${keyword}" target="_blank" data-item-type="scoped_search">
          <div class="jump-to-octicon js-jump-to-octicon flex-shrink-0 mr-2 text-center ">
            <svg title="Search" aria-label="Search" role="img" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-search js-jump-to-octicon-search flex-shrink-0">
                <path fill-rule="evenodd" d="M11.5 7a4.499 4.499 0 11-8.998 0A4.499 4.499 0 0111.5 7zm-.82 4.74a6 6 0 111.06-1.06l3.04 3.04a.75.75 0 11-1.06 1.06l-3.04-3.04z"></path>
            </svg>
          </div>    

          <div
            class="title jump-to-suggestion-name js-jump-to-suggestion-name flex-auto overflow-hidden text-left no-wrap css-truncate css-truncate-target">
            ${keyword}
          </div>

          <div aria-hidden="true" style="color: var(--color-fg-muted);"
            class="color-bg-primary js-jump border rounded-2 flex-shrink-0 color-bg-subtle px-1 ml-1 f6 d-on-nav-focus js-jump-to-badge-jump">
            Google search
            <span class="d-inline-block ml-1 v-align-middle">↵</span>
          </div>
        </a>
      </li>
    `
  }

  const stripHtml = (html) => {
    let tmp = document.createElement('div');
    tmp.innerHTML = html;

    
    const styles = tmp.getElementsByTagName('style');
    while(styles[0]) {
      styles[0].parentNode.removeChild(styles[0]);
    }

    
    const scripts = tmp.getElementsByTagName('script');
    while(scripts[0]) {
      scripts[0].parentNode.removeChild(scripts[0]);
    }
    
    return tmp.textContent || tmp.innerText || "";
  }

  const inputDom = document.querySelector(".Header-search-input");
  const resultDom = document.getElementById('jump-to-results');
  let debounceTimer;
  let parser;
  let xmlDoc;

  const search = (_keyword) => {

    resultDom.innerHTML = '';

    const keyword = _keyword;

    if (!keyword) return;

    const progressDom = document.getElementById('search-progress');
    if (progressDom && progressDom.classList.contains('d-none')) {
      progressDom.classList.remove('d-none');
    }

    localStorage.setItem('keyword', keyword);
    fetch(`${host.indexOf('localhost') > -1 ? 'http://' : 'https://'}${host}/index.xml`).then(resp => resp.text()).then(async (res) => {
      parser = new DOMParser();
      xmlDoc = parser.parseFromString(res, 'text/xml');
      const linkResult = xmlDoc.getElementsByTagName('link');
      const titleResult = xmlDoc.getElementsByTagName('title');
      const arr = [];

      const matched = [];
      await (async function searchLink() {
        for (let i = 0; i < linkResult.length; i++) {
          await fetch(linkResult[i].textContent).then(resp => resp.text().then(res => {
            const pureText = stripHtml(res);
            if (pureText.indexOf(keyword) >= 0) {
              matched.push(i);
            }
          }))
        }
      })();

      const googleSearchItem = createGoogleSearchItem(keyword);
      const node= document.createRange().createContextualFragment(googleSearchItem);
      resultDom.appendChild(node);

      matched.map((itemIndex, index) => {
        const r = createSearchItem(titleResult[itemIndex].textContent, linkResult[itemIndex].textContent, index + 1);
        const node = document.createRange().createContextualFragment(r);
        resultDom.appendChild(node);
      });

      if (progressDom && !progressDom.classList.contains('d-none')) {
        progressDom.classList.add('d-none');
      }
    });
  }

  const debounce = (callback, time) => {
    window.clearTimeout(debounceTimer);
    debounceTimer = window.setTimeout(callback, time);
  };

  ['focus', 'input'].forEach(event => {
    inputDom.addEventListener(event, (e) => {
      debounce(() => search(e.target.value), 500);
    }, false);
  });

  inputDom.addEventListener('blur', () => {
    setTimeout(() => {
      resultDom.innerHTML = '';
    }, 100);
  });

</script>






</html>